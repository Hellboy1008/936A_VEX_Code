#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  baseRightIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  baseLeftIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           baseRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           baseLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           mobileLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mobileRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armLeft,       tmotorNone, openLoop)
#pragma config(Motor,  port7,           armRight,      tmotorNone, openLoop)
#pragma config(Motor,  port8,           armClaw,       tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(300)
#pragma userControlDuration(900)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
void mobileUp(){
	motor[mobileLeft] = -127;
	motor[mobileRight] = -127;
	wait1Msec(400);
}

void mobileDown(){
	motor[mobileLeft] = 127;
	motor[mobileRight] = 127;
	wait1Msec(400);
}

void mobileStop(){
	motor[mobileLeft] = 0;
	motor[mobileRight] = 0;
}

void mobileStay(){
	motor[mobileLeft] = -63;
	motor[mobileRight] = -63;
}

void mobileStayH(){
	motor[mobileLeft] = -20;
	motor[mobileRight] = -20;
}

void clearEncoderValue(){
	nMotorEncoder[baseLeft] = 0;
	nMotorEncoder[baseRight] = 0;
}

void moveForward(float inches){
	clearEncoderValue();
	float ratioToLeft = 0.9;
	while (nMotorEncoder[baseRight] > -50*inches){
		motor[baseLeft] = -80;
		motor[baseRight] = -80*ratioToLeft;
	}
}

void charge(){
	motor[baseLeft] = -120;
	motor[baseRight] = -110;
}

void wiggle(){
	motor[baseLeft] = -60;
	motor[baseRight] = -50;
	wait1Msec(800);
	motor[baseLeft] = 60;
	motor[baseRight] = 50;
	wait1Msec(500);
	motor[baseLeft] = 80;
	motor[baseRight] = -70;
	wait1Msec(100);
	motor[baseLeft] = -80;
	motor[baseRight] = 70;
	wait1Msec(100);
}

void moveBackward(float inches){
	clearEncoderValue();
	float ratioToLeft = 0.9;
	while (nMotorEncoder[baseRight] < 50*inches){
		motor[baseLeft] = 80;
		motor[baseRight] = 80*ratioToLeft;
	}
}

void rotateSmall(){
	clearEncoderValue();
	while (nMotorEncoder[baseRight] > -350){
		motor[baseLeft] = 80;
		motor[baseRight] = -70;
	}
}

void stopMoving() {
	motor[baseLeft] = 0;
	motor[baseRight] = 0;
}

void pre_auton()
{
	clearEncoderValue();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	clearEncoderValue();
	moveForward(45);
	stopMoving();
	mobileUp();
	mobileStayH();
	moveBackward(55);
	stopMoving();
	rotateSmall();
	stopMoving();
	mobileUp();
	mobileStay();
	charge();
	wait1Msec(2500);
	stopMoving();
	wiggle();
	wiggle();
	wiggle();
	mobileDown();
	moveBackward(20);
	stopMoving();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task base()
{
	int channelvar_three = 0;
	int channelvar_four = 0;
	int channelvar_one = 0;
	int channelvar_two = 0;
	int threshold = 15;

	while(true){

		//creating a deadzone for channel 3
		if (abs(vexRT[Ch3]) > threshold){
			channelvar_three = vexRT[Ch3];
		}
		else{
			channelvar_three = 0;
		}

		//creating a deadzone for channel 4
		if (abs(vexRT[Ch4]) > threshold){
			channelvar_four = vexRT[Ch4];
		}
		else{
			channelvar_four = 0;
		}

		//creating a deadzone for channel 1
		if (abs(vexRT[Ch1]) > threshold){
			channelvar_one = vexRT[Ch1];
		}
		else{
			channelvar_one = 0;
		}

		//creating a deadzone for channel 2
		if (abs(vexRT[Ch2]) > threshold){
			channelvar_two = vexRT[Ch2];
		}
		else{
			channelvar_two = 0;
		}

		//moving the robot

		motor[baseRight] = (-channelvar_two);
		motor[baseLeft]  = (-channelvar_three);
	}
}

task mobileGoal()
{
	bool mobile_up = false;
	while (true){
		if(vexRT[Btn7UXmtr2]== 1){
			mobileUp();
			mobile_up = true;
		}
		if(vexRT[Btn7DXmtr2]== 1){
			mobileDown();
			mobile_up = false;
		}
		if (mobile_up == true){
			mobileStay();
			} else{
			mobileStop();
		}
	}
}

task usercontrol()
{
	startTask(base);
	startTask(mobileGoal);
	while (true){
		wait1Msec(1);
	}
}
