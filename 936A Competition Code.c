#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           armRight,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           armLeft,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           clawOpen,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(300)
#pragma userControlDuration(900)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
void armUp(){
	motor[armLeft] = -120;
	motor[armRight] = -120;
}

void armDown(){
	motor[armLeft] = 50;
	motor[armRight] = 50;
}

void stopArm(){
	motor[armLeft] = -10;
	motor[armRight] = -10;
}

void clawO(){
	motor[clawOpen] = 50;
}

void clawC(){
	motor[clawOpen] = -50;
}

void clawS(){
	motor[clawOpen] = 0;
}
void moveForward(){

	motor[frontLeft] = 87;
	motor[frontRight] = 127;
	motor[backLeft] = 87;
	motor[backRight] = 87;

}

void moveBackward(){

	motor[frontLeft] = -87;
	motor[frontRight] = -127;
	motor[backLeft] = -87;
	motor[backRight] = -87;

}

void stopMoving() {

	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;

}

void rotateRight() {

	motor[frontLeft] = 87;
	motor[backLeft] = 127;
	motor[frontRight] = -87;
	motor[backRight] = -87;
}

void rotateLeft() {

	motor[frontLeft] = -87;
	motor[backLeft] = -127;
	motor[frontRight] = 87;
	motor[backRight] = 87;
}

void pre_auton()
{
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	moveForward();
	wait1Msec(3000);
	stopMoving();
	rotateLeft();
	wait1Msec(1900);
	stopMoving();
	moveForward();
	wait1Msec(1000);
	stopMoving();
	rotateLeft();
	wait1Msec(600);
	stopMoving();
	moveBackward();
	wait1Msec(1000);
	stopMoving();
	rotateLeft();
	wait1Msec(1900);
	stopMoving();
	moveBackward();
	wait1Msec(4500);
	stopMoving();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	int channelvar_one = 0;
	int channelvar_three = 0;
	int channelvar_four = 0;
	int threshold = 15;

	while(true){
		//creating a deadzone for channel 2
		if (abs(vexRT[Ch1]) > threshold){
			channelvar_one = vexRT[Ch1];
		}
		else{
			channelvar_one= 0;
		}

		//creating a deadzone for channel 3
		if (abs(vexRT[Ch3]) > threshold){
			channelvar_three = vexRT[Ch3];
		}
		else{
			channelvar_three = 0;
		}

		//creating a deadzone for channel 4
		if (abs(vexRT[Ch4]) > threshold){
			channelvar_four = vexRT[Ch4];
		}
		else{
			channelvar_four = 0;
		}

		//moving the robot

		motor[frontRight] = channelvar_three - channelvar_four + channelvar_one;
		motor[backRight] = channelvar_three - channelvar_four - channelvar_one;
		motor[frontLeft]  = channelvar_three + channelvar_four - channelvar_one;
		motor[backLeft]  = channelvar_three + channelvar_four + channelvar_one;

		while(vexRT[Btn5U]== 1){
			armUp();
		}
		while(vexRT[Btn5D]== 1){
			armDown();
		}
		stopArm();
		while(vexRT[Btn6U] == 1){
			clawO();
		}
		while(vexRT[Btn6D]== 1){
			clawC();
		}
		clawS();
	}
}
